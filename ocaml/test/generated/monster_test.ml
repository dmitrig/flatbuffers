(** Automatically generated by the FlatBuffers compiler

    root type: MyGame.Example.Monster (//monster_test.fbs)
    flatc version: 23.3.3
*)

[@@@warning "-32"]

module Rt = Flatbuffers.Runtime

module Struct = struct

  let rec set_ability__4 b i (id_, distance_) =
    Rt.Builder.set_uint b (i + 0) id_;
    Rt.Builder.set_uint b (i + 4) distance_;

  and set_struct_of_structs__6 b i (a_, b_, c_) =
    set_ability__4 b (i + 0) a_;
    set_test__5 b (i + 8) b_;
    set_ability__4 b (i + 12) c_;

  and set_struct_of_structs_of_structs__7 b i (a_) =
    set_struct_of_structs__6 b (i + 0) a_;

  and set_test__5 b i (a_, b_) =
    Rt.Builder.set_short b (i + 0) a_;
    Rt.Builder.set_byte b (i + 2) b_;
    Rt.Builder.set_padding b (i + 3) 1;

  and set_vec3__8 b i (x_, y_, z_, test1_, test2_, test3_) =
    Rt.Builder.set_float b (i + 0) x_;
    Rt.Builder.set_float b (i + 4) y_;
    Rt.Builder.set_float b (i + 8) z_;
    Rt.Builder.set_padding b (i + 12) 4;
    Rt.Builder.set_double b (i + 16) test1_;
    Rt.Builder.set_ubyte b (i + 24) test2_;
    Rt.Builder.set_padding b (i + 25) 1;
    set_test__5 b (i + 26) test3_;
    Rt.Builder.set_padding b (i + 30) 2;

  and set_unused__9 b i (a_) =
    Rt.Builder.set_int b (i + 0) a_;
end

module Union = struct
  let read_table_any__10 ?none ?monster ?test_simple_table_with_enum ?my_game_example2_monster ~default b i t o =
    match Rt.UType.to_default t with
    | 0L when Option.is_some none -> Option.get none
    | 1L when Option.is_some monster -> Option.get monster (Rt.Ref.read_table b o i)
    | 2L when Option.is_some test_simple_table_with_enum -> Option.get test_simple_table_with_enum (Rt.Ref.read_table b o i)
    | 3L when Option.is_some my_game_example2_monster -> Option.get my_game_example2_monster (Rt.Ref.read_table b o i)
    | _ -> default t

  let read_table_any_ambiguous_aliases__11 ?none ?m1 ?m2 ?m3 ~default b i t o =
    match Rt.UType.to_default t with
    | 0L when Option.is_some none -> Option.get none
    | 1L when Option.is_some m1 -> Option.get m1 (Rt.Ref.read_table b o i)
    | 2L when Option.is_some m2 -> Option.get m2 (Rt.Ref.read_table b o i)
    | 3L when Option.is_some m3 -> Option.get m3 (Rt.Ref.read_table b o i)
    | _ -> default t

  let read_table_any_unique_aliases__12 ?none ?m ?ts ?m2 ~default b i t o =
    match Rt.UType.to_default t with
    | 0L when Option.is_some none -> Option.get none
    | 1L when Option.is_some m -> Option.get m (Rt.Ref.read_table b o i)
    | 2L when Option.is_some ts -> Option.get ts (Rt.Ref.read_table b o i)
    | 3L when Option.is_some m2 -> Option.get m2 (Rt.Ref.read_table b o i)
    | _ -> default t
end

module TableA = struct
  type t

  module Vector = Rt.Ref.Vector

  let[@inline] b b o = Rt.Ref.read_table_opt b o 4

  module Builder = struct
    type t = Rt.Builder.t

    let start b = Rt.Builder.start_table b ~n_fields:1
    let finish b = Rt.Builder.end_table b
    let add_b = Rt.Ref.push_slot 0
  end
end

module MyGame = struct
  module OtherNameSpace = struct
    module FromInclude = struct
      type t = Rt.Long.t

      let include_val = Rt.Long.of_default 0L

      let to_string e =
        match Rt.Long.to_default e with
        | 0L -> "include_val"
        | x -> "<MyGame.OtherNameSpace.FromInclude: " ^ (Int64.to_string x) ^ ">"

      module Vector = Rt.Long.Vector
    end

    module Unused = struct
      type t = (Rt.Int.t)

      module Vector = Rt.Struct.Vector (struct type builder_elt = t let size = 4 let set = Struct.set_unused__9 end)

      let[@inline] a b s = Rt.Int.read_offset b s 0
    end

    module TableB = struct
      type t

      module Vector = Rt.Ref.Vector

      let[@inline] a b o = Rt.Ref.read_table_opt b o 4

      module Builder = struct
        type t = Rt.Builder.t

        let start b = Rt.Builder.start_table b ~n_fields:1
        let finish b = Rt.Builder.end_table b
        let add_a = Rt.Ref.push_slot 0
      end
    end
  end (* OtherNameSpace *)

  module InParentNamespace = struct
    type t

    module Vector = Rt.Ref.Vector


    module Builder = struct
      type t = Rt.Builder.t

      let start b = Rt.Builder.start_table b ~n_fields:0
      let finish b = Rt.Builder.end_table b
    end
  end

  module Example2 = struct
    module Monster = struct
      type t

      module Vector = Rt.Ref.Vector


      module Builder = struct
        type t = Rt.Builder.t

        let start b = Rt.Builder.start_table b ~n_fields:0
        let finish b = Rt.Builder.end_table b
      end
    end
  end (* Example2 *)

  module Example = struct
    module Race = struct
      type t = Rt.Byte.t

      let none = Rt.Byte.of_default (-1L)
      let human = Rt.Byte.of_default 0L
      let dwarf = Rt.Byte.of_default 1L
      let elf = Rt.Byte.of_default 2L

      let to_string e =
        match Rt.Byte.to_default e with
        | (-1L) -> "none"
        | 0L -> "human"
        | 1L -> "dwarf"
        | 2L -> "elf"
        | x -> "<MyGame.Example.Race: " ^ (Int64.to_string x) ^ ">"

      module Vector = Rt.Byte.Vector
    end

    module LongEnum = struct
      type t = Rt.ULong.t

      let long_one = Rt.ULong.of_default 2L
      let long_two = Rt.ULong.of_default 4L
      let long_big = Rt.ULong.of_default 1099511627776L

      let to_string e =
        match Rt.ULong.to_default e with
        | 2L -> "long_one"
        | 4L -> "long_two"
        | 1099511627776L -> "long_big"
        | x -> "<MyGame.Example.LongEnum: " ^ (Int64.to_string x) ^ ">"

      module Vector = Rt.ULong.Vector
    end

    module Color = struct
      type t = Rt.UByte.t

      let red = Rt.UByte.of_default 1L
      let green = Rt.UByte.of_default 2L
      let blue = Rt.UByte.of_default 8L

      let to_string e =
        match Rt.UByte.to_default e with
        | 1L -> "red"
        | 2L -> "green"
        | 8L -> "blue"
        | x -> "<MyGame.Example.Color: " ^ (Int64.to_string x) ^ ">"

      module Vector = Rt.UByte.Vector
    end

    module AnyUniqueAliases = struct
      type t = Rt.UType.t

      let none = Rt.UType.of_default 0L
      let m = Rt.UType.of_default 1L
      let ts = Rt.UType.of_default 2L
      let m2 = Rt.UType.of_default 3L

      let to_string e =
        match Rt.UType.to_default e with
        | 0L -> "none"
        | 1L -> "m"
        | 2L -> "ts"
        | 3L -> "m2"
        | x -> "<MyGame.Example.AnyUniqueAliases: " ^ (Int64.to_string x) ^ ">"
    end

    module AnyAmbiguousAliases = struct
      type t = Rt.UType.t

      let none = Rt.UType.of_default 0L
      let m1 = Rt.UType.of_default 1L
      let m2 = Rt.UType.of_default 2L
      let m3 = Rt.UType.of_default 3L

      let to_string e =
        match Rt.UType.to_default e with
        | 0L -> "none"
        | 1L -> "m1"
        | 2L -> "m2"
        | 3L -> "m3"
        | x -> "<MyGame.Example.AnyAmbiguousAliases: " ^ (Int64.to_string x) ^ ">"
    end

    module Any = struct
      type t = Rt.UType.t

      let none = Rt.UType.of_default 0L
      let monster = Rt.UType.of_default 1L
      let test_simple_table_with_enum = Rt.UType.of_default 2L
      let my_game_example2_monster = Rt.UType.of_default 3L

      let to_string e =
        match Rt.UType.to_default e with
        | 0L -> "none"
        | 1L -> "monster"
        | 2L -> "test_simple_table_with_enum"
        | 3L -> "my_game_example2_monster"
        | x -> "<MyGame.Example.Any: " ^ (Int64.to_string x) ^ ">"
    end

    module Vec3 = struct
      type t = (Rt.Float.t * Rt.Float.t * Rt.Float.t * Rt.Double.t * Rt.UByte.t * (Rt.Short.t * Rt.Byte.t))

      module Vector = Rt.Struct.Vector (struct type builder_elt = t let size = 32 let set = Struct.set_vec3__8 end)

      let[@inline] x b s = Rt.Float.read_offset b s 0
      let[@inline] y b s = Rt.Float.read_offset b s 4
      let[@inline] z b s = Rt.Float.read_offset b s 8
      let[@inline] test1 b s = Rt.Double.read_offset b s 16
      let[@inline] test2 b s = Rt.UByte.read_offset b s 24
      let[@inline] test3 b s = Rt.Struct.read_offset b s 26
    end

    module TypeAliases = struct
      type t

      module Vector = Rt.Ref.Vector

      let[@inline] i8 b o = Rt.Byte.(read_table_default b o 4 ~default:(of_default 0L))
      let[@inline] u8 b o = Rt.UByte.(read_table_default b o 6 ~default:(of_default 0L))
      let[@inline] i16 b o = Rt.Short.(read_table_default b o 8 ~default:(of_default 0L))
      let[@inline] u16 b o = Rt.UShort.(read_table_default b o 10 ~default:(of_default 0L))
      let[@inline] i32 b o = Rt.Int.(read_table_default b o 12 ~default:(of_default 0L))
      let[@inline] u32 b o = Rt.UInt.(read_table_default b o 14 ~default:(of_default 0L))
      let[@inline] i64 b o = Rt.Long.(read_table_default b o 16 ~default:(of_default 0L))
      let[@inline] u64 b o = Rt.ULong.(read_table_default b o 18 ~default:(of_default 0L))
      let[@inline] f32 b o = Rt.Float.(read_table_default b o 20 ~default:(of_default 0.0))
      let[@inline] f64 b o = Rt.Double.(read_table_default b o 22 ~default:(of_default 0.0))
      let[@inline] v8 b o = Rt.Ref.read_table_opt b o 24
      let[@inline] vf64 b o = Rt.Ref.read_table_opt b o 26

      module Builder = struct
        type t = Rt.Builder.t

        let start b = Rt.Builder.start_table b ~n_fields:12
        let finish b = Rt.Builder.end_table b
        let add_i8 = Rt.Byte.(push_slot_default 0 ~default:(of_default 0L))
        let add_u8 = Rt.UByte.(push_slot_default 1 ~default:(of_default 0L))
        let add_i16 = Rt.Short.(push_slot_default 2 ~default:(of_default 0L))
        let add_u16 = Rt.UShort.(push_slot_default 3 ~default:(of_default 0L))
        let add_i32 = Rt.Int.(push_slot_default 4 ~default:(of_default 0L))
        let add_u32 = Rt.UInt.(push_slot_default 5 ~default:(of_default 0L))
        let add_i64 = Rt.Long.(push_slot_default 6 ~default:(of_default 0L))
        let add_u64 = Rt.ULong.(push_slot_default 7 ~default:(of_default 0L))
        let add_f32 = Rt.Float.(push_slot_default 8 ~default:(of_default 0.0))
        let add_f64 = Rt.Double.(push_slot_default 9 ~default:(of_default 0.0))
        let add_v8 = Rt.Ref.push_slot 10
        let add_vf64 = Rt.Ref.push_slot 11
      end
    end

    module TestSimpleTableWithEnum = struct
      type t

      module Vector = Rt.Ref.Vector

      let[@inline] color b o = Rt.UByte.(read_table_default b o 4 ~default:(of_default 2L))

      module Builder = struct
        type t = Rt.Builder.t

        let start b = Rt.Builder.start_table b ~n_fields:1
        let finish b = Rt.Builder.end_table b
        let add_color = Rt.UByte.(push_slot_default 0 ~default:(of_default 2L))
      end
    end

    module Test = struct
      type t = (Rt.Short.t * Rt.Byte.t)

      module Vector = Rt.Struct.Vector (struct type builder_elt = t let size = 4 let set = Struct.set_test__5 end)

      let[@inline] a b s = Rt.Short.read_offset b s 0
      let[@inline] b b s = Rt.Byte.read_offset b s 2
    end

    module StructOfStructsOfStructs = struct
      type t = (((Rt.UInt.t * Rt.UInt.t) * (Rt.Short.t * Rt.Byte.t) * (Rt.UInt.t * Rt.UInt.t)))

      module Vector = Rt.Struct.Vector (struct type builder_elt = t let size = 20 let set = Struct.set_struct_of_structs_of_structs__7 end)

      let[@inline] a b s = Rt.Struct.read_offset b s 0
    end

    module StructOfStructs = struct
      type t = ((Rt.UInt.t * Rt.UInt.t) * (Rt.Short.t * Rt.Byte.t) * (Rt.UInt.t * Rt.UInt.t))

      module Vector = Rt.Struct.Vector (struct type builder_elt = t let size = 20 let set = Struct.set_struct_of_structs__6 end)

      let[@inline] a b s = Rt.Struct.read_offset b s 0
      let[@inline] b b s = Rt.Struct.read_offset b s 8
      let[@inline] c b s = Rt.Struct.read_offset b s 12
    end

    module Stat = struct
      type t

      module Vector = Rt.Ref.Vector

      let[@inline] id b o = Rt.Ref.read_table_opt b o 4
      let[@inline] val_ b o = Rt.Long.(read_table_default b o 6 ~default:(of_default 0L))
      let[@inline] count b o = Rt.UShort.(read_table_default b o 8 ~default:(of_default 0L))

      module Builder = struct
        type t = Rt.Builder.t

        let start b = Rt.Builder.start_table b ~n_fields:3
        let finish b = Rt.Builder.end_table b
        let add_id = Rt.Ref.push_slot 0
        let add_val_ = Rt.Long.(push_slot_default 1 ~default:(of_default 0L))
        let add_count = Rt.UShort.(push_slot_default 2 ~default:(of_default 0L))
      end
    end

    module Referrable = struct
      type t

      module Vector = Rt.Ref.Vector

      let[@inline] id b o = Rt.ULong.(read_table_default b o 4 ~default:(of_default 0L))

      module Builder = struct
        type t = Rt.Builder.t

        let start b = Rt.Builder.start_table b ~n_fields:1
        let finish b = Rt.Builder.end_table b
        let add_id = Rt.ULong.(push_slot_default 0 ~default:(of_default 0L))
      end
    end

    module Monster = struct
      type t

      module Vector = Rt.Ref.Vector

      let extension = Some "mon"
      let identifier = Some "MONS"
      let has_identifier ?(size_prefixed = false) ?(off = 0) p b = Rt.get_identifier p b ~size_prefixed ~off = Option.get identifier
      let[@inline] root ?(size_prefixed = false) ?(off = 0) p b = Rt.get_root p b ~size_prefixed ~off
      let finish_buf ?(size_prefixed = false) = Rt.Builder.finish ?identifier ~size_prefixed

      let[@inline] pos b o = Rt.Struct.read_table_opt b o 4
      let[@inline] mana b o = Rt.Short.(read_table_default b o 6 ~default:(of_default 150L))
      let[@inline] hp b o = Rt.Short.(read_table_default b o 8 ~default:(of_default 100L))
      let[@inline] name b o = Rt.Ref.read_table b o 10
      let[@inline] inventory b o = Rt.Ref.read_table_opt b o 14
      let[@inline] color b o = Rt.UByte.(read_table_default b o 16 ~default:(of_default 8L))
      let[@inline] test_type b o = Rt.UType.(read_table_default b o 18 ~default:(of_default 0L))
      let[@inline] test ?none ?monster ?test_simple_table_with_enum ?my_game_example2_monster ~default b o = Union.read_table_any__10 b 20 (test_type b o) ?none ?monster ?test_simple_table_with_enum ?my_game_example2_monster ~default o
      let[@inline] test4 b o = Rt.Ref.read_table_opt b o 22
      let[@inline] testarrayofstring b o = Rt.Ref.read_table_opt b o 24
      let[@inline] testarrayoftables b o = Rt.Ref.read_table_opt b o 26
      let[@inline] enemy b o = Rt.Ref.read_table_opt b o 28
      let[@inline] testnestedflatbuffer b o = Rt.Ref.read_table_opt b o 30
      let[@inline] testempty b o = Rt.Ref.read_table_opt b o 32
      let[@inline] testbool b o = Rt.Bool.(read_table_default b o 34 ~default:(of_default false))
      let[@inline] testhashs32_fnv1 b o = Rt.Int.(read_table_default b o 36 ~default:(of_default 0L))
      let[@inline] testhashu32_fnv1 b o = Rt.UInt.(read_table_default b o 38 ~default:(of_default 0L))
      let[@inline] testhashs64_fnv1 b o = Rt.Long.(read_table_default b o 40 ~default:(of_default 0L))
      let[@inline] testhashu64_fnv1 b o = Rt.ULong.(read_table_default b o 42 ~default:(of_default 0L))
      let[@inline] testhashs32_fnv1_a b o = Rt.Int.(read_table_default b o 44 ~default:(of_default 0L))
      let[@inline] testhashu32_fnv1_a b o = Rt.UInt.(read_table_default b o 46 ~default:(of_default 0L))
      let[@inline] testhashs64_fnv1_a b o = Rt.Long.(read_table_default b o 48 ~default:(of_default 0L))
      let[@inline] testhashu64_fnv1_a b o = Rt.ULong.(read_table_default b o 50 ~default:(of_default 0L))
      let[@inline] testarrayofbools b o = Rt.Ref.read_table_opt b o 52
      let[@inline] testf b o = Rt.Float.(read_table_default b o 54 ~default:(of_default 3.14159))
      let[@inline] testf2 b o = Rt.Float.(read_table_default b o 56 ~default:(of_default 3.0))
      let[@inline] testf3 b o = Rt.Float.(read_table_default b o 58 ~default:(of_default 0.0))
      let[@inline] testarrayofstring2 b o = Rt.Ref.read_table_opt b o 60
      let[@inline] testarrayofsortedstruct b o = Rt.Ref.read_table_opt b o 62
      let[@inline] flex b o = Rt.Ref.read_table_opt b o 64
      let[@inline] test5 b o = Rt.Ref.read_table_opt b o 66
      let[@inline] vector_of_longs b o = Rt.Ref.read_table_opt b o 68
      let[@inline] vector_of_doubles b o = Rt.Ref.read_table_opt b o 70
      let[@inline] parent_namespace_test b o = Rt.Ref.read_table_opt b o 72
      let[@inline] vector_of_referrables b o = Rt.Ref.read_table_opt b o 74
      let[@inline] single_weak_reference b o = Rt.ULong.(read_table_default b o 76 ~default:(of_default 0L))
      let[@inline] vector_of_weak_references b o = Rt.Ref.read_table_opt b o 78
      let[@inline] vector_of_strong_referrables b o = Rt.Ref.read_table_opt b o 80
      let[@inline] co_owning_reference b o = Rt.ULong.(read_table_default b o 82 ~default:(of_default 0L))
      let[@inline] vector_of_co_owning_references b o = Rt.Ref.read_table_opt b o 84
      let[@inline] non_owning_reference b o = Rt.ULong.(read_table_default b o 86 ~default:(of_default 0L))
      let[@inline] vector_of_non_owning_references b o = Rt.Ref.read_table_opt b o 88
      let[@inline] any_unique_type b o = Rt.UType.(read_table_default b o 90 ~default:(of_default 0L))
      let[@inline] any_unique ?none ?m ?ts ?m2 ~default b o = Union.read_table_any_unique_aliases__12 b 92 (any_unique_type b o) ?none ?m ?ts ?m2 ~default o
      let[@inline] any_ambiguous_type b o = Rt.UType.(read_table_default b o 94 ~default:(of_default 0L))
      let[@inline] any_ambiguous ?none ?m1 ?m2 ?m3 ~default b o = Union.read_table_any_ambiguous_aliases__11 b 96 (any_ambiguous_type b o) ?none ?m1 ?m2 ?m3 ~default o
      let[@inline] vector_of_enums b o = Rt.Ref.read_table_opt b o 98
      let[@inline] signed_enum b o = Rt.Byte.(read_table_default b o 100 ~default:(of_default (-1L)))
      let[@inline] testrequirednestedflatbuffer b o = Rt.Ref.read_table_opt b o 102
      let[@inline] scalar_key_sorted_tables b o = Rt.Ref.read_table_opt b o 104
      let[@inline] native_inline b o = Rt.Struct.read_table_opt b o 106
      let[@inline] long_enum_non_enum_default b o = Rt.ULong.(read_table_default b o 108 ~default:(of_default 0L))
      let[@inline] long_enum_normal_default b o = Rt.ULong.(read_table_default b o 110 ~default:(of_default 2L))
      let[@inline] nan_default b o = Rt.Float.(read_table_default b o 112 ~default:(of_default nan))
      let[@inline] inf_default b o = Rt.Float.(read_table_default b o 114 ~default:(of_default infinity))
      let[@inline] positive_inf_default b o = Rt.Float.(read_table_default b o 116 ~default:(of_default infinity))
      let[@inline] infinity_default b o = Rt.Float.(read_table_default b o 118 ~default:(of_default infinity))
      let[@inline] positive_infinity_default b o = Rt.Float.(read_table_default b o 120 ~default:(of_default infinity))
      let[@inline] negative_inf_default b o = Rt.Float.(read_table_default b o 122 ~default:(of_default neg_infinity))
      let[@inline] negative_infinity_default b o = Rt.Float.(read_table_default b o 124 ~default:(of_default neg_infinity))
      let[@inline] double_inf_default b o = Rt.Double.(read_table_default b o 126 ~default:(of_default infinity))

      module Builder = struct
        type t = Rt.Builder.t

        let start b = Rt.Builder.start_table b ~n_fields:62
        let finish b = Rt.Builder.end_table b
        let add_pos = Rt.Struct.push_slot Struct.set_vec3__8 32 8 0
        let add_mana = Rt.Short.(push_slot_default 1 ~default:(of_default 150L))
        let add_hp = Rt.Short.(push_slot_default 2 ~default:(of_default 100L))
        let add_name = Rt.Ref.push_slot 3
        let add_inventory = Rt.Ref.push_slot 5
        let add_color = Rt.UByte.(push_slot_default 6 ~default:(of_default 8L))
        let add_test_monster = Rt.Ref.push_union 7 8 Any.monster
        let add_test_test_simple_table_with_enum = Rt.Ref.push_union 7 8 Any.test_simple_table_with_enum
        let add_test_my_game_example2_monster = Rt.Ref.push_union 7 8 Any.my_game_example2_monster
        let add_test4 = Rt.Ref.push_slot 9
        let add_testarrayofstring = Rt.Ref.push_slot 10
        let add_testarrayoftables = Rt.Ref.push_slot 11
        let add_enemy = Rt.Ref.push_slot 12
        let add_testnestedflatbuffer = Rt.Ref.push_slot 13
        let add_testempty = Rt.Ref.push_slot 14
        let add_testbool = Rt.Bool.(push_slot_default 15 ~default:(of_default false))
        let add_testhashs32_fnv1 = Rt.Int.(push_slot_default 16 ~default:(of_default 0L))
        let add_testhashu32_fnv1 = Rt.UInt.(push_slot_default 17 ~default:(of_default 0L))
        let add_testhashs64_fnv1 = Rt.Long.(push_slot_default 18 ~default:(of_default 0L))
        let add_testhashu64_fnv1 = Rt.ULong.(push_slot_default 19 ~default:(of_default 0L))
        let add_testhashs32_fnv1_a = Rt.Int.(push_slot_default 20 ~default:(of_default 0L))
        let add_testhashu32_fnv1_a = Rt.UInt.(push_slot_default 21 ~default:(of_default 0L))
        let add_testhashs64_fnv1_a = Rt.Long.(push_slot_default 22 ~default:(of_default 0L))
        let add_testhashu64_fnv1_a = Rt.ULong.(push_slot_default 23 ~default:(of_default 0L))
        let add_testarrayofbools = Rt.Ref.push_slot 24
        let add_testf = Rt.Float.(push_slot_default 25 ~default:(of_default 3.14159))
        let add_testf2 = Rt.Float.(push_slot_default 26 ~default:(of_default 3.0))
        let add_testf3 = Rt.Float.(push_slot_default 27 ~default:(of_default 0.0))
        let add_testarrayofstring2 = Rt.Ref.push_slot 28
        let add_testarrayofsortedstruct = Rt.Ref.push_slot 29
        let add_flex = Rt.Ref.push_slot 30
        let add_test5 = Rt.Ref.push_slot 31
        let add_vector_of_longs = Rt.Ref.push_slot 32
        let add_vector_of_doubles = Rt.Ref.push_slot 33
        let add_parent_namespace_test = Rt.Ref.push_slot 34
        let add_vector_of_referrables = Rt.Ref.push_slot 35
        let add_single_weak_reference = Rt.ULong.(push_slot_default 36 ~default:(of_default 0L))
        let add_vector_of_weak_references = Rt.Ref.push_slot 37
        let add_vector_of_strong_referrables = Rt.Ref.push_slot 38
        let add_co_owning_reference = Rt.ULong.(push_slot_default 39 ~default:(of_default 0L))
        let add_vector_of_co_owning_references = Rt.Ref.push_slot 40
        let add_non_owning_reference = Rt.ULong.(push_slot_default 41 ~default:(of_default 0L))
        let add_vector_of_non_owning_references = Rt.Ref.push_slot 42
        let add_any_unique_m = Rt.Ref.push_union 43 44 AnyUniqueAliases.m
        let add_any_unique_ts = Rt.Ref.push_union 43 44 AnyUniqueAliases.ts
        let add_any_unique_m2 = Rt.Ref.push_union 43 44 AnyUniqueAliases.m2
        let add_any_ambiguous_m1 = Rt.Ref.push_union 45 46 AnyAmbiguousAliases.m1
        let add_any_ambiguous_m2 = Rt.Ref.push_union 45 46 AnyAmbiguousAliases.m2
        let add_any_ambiguous_m3 = Rt.Ref.push_union 45 46 AnyAmbiguousAliases.m3
        let add_vector_of_enums = Rt.Ref.push_slot 47
        let add_signed_enum = Rt.Byte.(push_slot_default 48 ~default:(of_default (-1L)))
        let add_testrequirednestedflatbuffer = Rt.Ref.push_slot 49
        let add_scalar_key_sorted_tables = Rt.Ref.push_slot 50
        let add_native_inline = Rt.Struct.push_slot Struct.set_test__5 4 2 51
        let add_long_enum_non_enum_default = Rt.ULong.(push_slot_default 52 ~default:(of_default 0L))
        let add_long_enum_normal_default = Rt.ULong.(push_slot_default 53 ~default:(of_default 2L))
        let add_nan_default = Rt.Float.(push_slot_default 54 ~default:(of_default nan))
        let add_inf_default = Rt.Float.(push_slot_default 55 ~default:(of_default infinity))
        let add_positive_inf_default = Rt.Float.(push_slot_default 56 ~default:(of_default infinity))
        let add_infinity_default = Rt.Float.(push_slot_default 57 ~default:(of_default infinity))
        let add_positive_infinity_default = Rt.Float.(push_slot_default 58 ~default:(of_default infinity))
        let add_negative_inf_default = Rt.Float.(push_slot_default 59 ~default:(of_default neg_infinity))
        let add_negative_infinity_default = Rt.Float.(push_slot_default 60 ~default:(of_default neg_infinity))
        let add_double_inf_default = Rt.Double.(push_slot_default 61 ~default:(of_default infinity))
      end
    end

    module Ability = struct
      type t = (Rt.UInt.t * Rt.UInt.t)

      module Vector = Rt.Struct.Vector (struct type builder_elt = t let size = 8 let set = Struct.set_ability__4 end)

      let[@inline] id b s = Rt.UInt.read_offset b s 0
      let[@inline] distance b s = Rt.UInt.read_offset b s 4
    end
  end (* Example *)
end (* MyGame *)
